import re
import numpy as np
import pickle
import tensorflow as tf
from tensorflow.keras.preprocessing.sequence import pad_sequences
import google.generativeai as genai

# -------------------------------
# Set up Gemini API key and Model
# -------------------------------
genai.configure(api_key="AIzaSyCmGgnhKnOg_bMXOKXQZ6_iyOtOHPNu8ro")
# Let's get Gemini ready to roll, using the flash model for faster responses.
gemini_model = genai.GenerativeModel("models/gemini-2.0-flash")

# -------------------------------
# Load Saved Model and Tokenizer
# -------------------------------
# Load up our trained recipe model and the tokenizer we saved earlier.
rnn_model = tf.keras.models.load_model("./trained_model/recipe_generator_model.h5")
with open("./trained_model/tokenizer.pickle", "rb") as handle:
    tokenizer = pickle.load(handle)

# We need to keep the sequence length the same as when we trained the model.
max_sequence_len = 50

# -------------------------------
# Utility: Process Ingredients Input
# -------------------------------
def process_ingredients(user_input):
    """
    Takes the ingredients the user gave us, splits them by commas,
    cleans them up a bit, and returns the first 5.
    """
    ingredients_list = [ing.strip().lower() for ing in user_input.split(",")]
    return ingredients_list[:5]

# -------------------------------
# Utility: Sample with Temperature
# -------------------------------
def sample_with_temperature(preds, temperature=1.0):
    """
    Adjusts the prediction probabilities based on the temperature,
    and then randomly selects a word index.
    """
    preds = np.asarray(preds).astype('float64')
    preds = np.log(preds + 1e-8) / temperature
    exp_preds = np.exp(preds)
    preds = exp_preds / np.sum(exp_preds)
    probas = np.random.multinomial(1, preds, 1)
    return np.argmax(probas)

# -------------------------------
# Function: Generate Text with a Given Seed using the RNN
# -------------------------------
def generate_text(seed_text, max_gen_words=50, stop_token="<end>", temperature=1.0):
    """
    Uses the RNN to generate text, one word at a time, based on the seed text.
    Stops when it hits the stop token or the max word count.
    """
    output_text = seed_text
    for _ in range(max_gen_words):
        token_list = tokenizer.texts_to_sequences([output_text])[0]
        token_list = pad_sequences([token_list], maxlen=max_sequence_len - 1, padding='pre')
        predicted_probs = rnn_model.predict(token_list, verbose=0)[0]
        predicted_index = sample_with_temperature(predicted_probs, temperature)
        # Find the actual word that corresponds to the predicted index.
        output_word = None
        for word, index in tokenizer.word_index.items():
            if index == predicted_index:
                output_word = word
                break
        if output_word is None:
            break
        if output_word == stop_token:
            break
        output_text += " " + output_word
    return output_text

# -------------------------------
# Function: Refine Recipe with Gemini
# -------------------------------
def refine_with_gemini(dish_name, procedure, input_ingredients):
    """
    Sends the generated recipe to Gemini to clean it up and make it more coherent.
    """
    ingredients_str = ", ".join(input_ingredients)
    prompt = f"""
Refine the following recipe generated by an RNN model.

Dish Name: {dish_name}
Procedure: {procedure}
Ingredients: {ingredients_str}

Please refine the recipe according to the following requirements:
- The dish name should be concise and include only words relevant to the dish.
- The procedure must use only the specified ingredients (i.e., {ingredients_str}) along with basic staples (such as salt, oil, tomato sauce, etc.). Do NOT include any ingredients that were not provided.
- Remove any repeated or extraneous words or phrases.
- Present the procedure as clear, step-by-step cooking instructions similar to the example below:

Heat the oil or ghee in a large pan or kadhai over medium heat.
Add the cumin seeds and let them crackle.
Add the finely chopped onion and sauté until golden brown.
Add the ginger-garlic paste and cook for another minute until the raw smell disappears.
Add the tomato puree or chopped tomatoes and cook until the oil separates from the mixture.
Add the paneer cubes to the pan, and gently mix.
Add the grated cheese, and stir gently.
Reduce the heat to low, cover the pan, and simmer for 5-7 minutes, or until the paneer is heated through and the flavors have melded.

Return the refined output in the following format:
Refined Dish Name:
<your refined dish name>
Refined Procedure:
<your refined procedure>
"""
    try:
        response = gemini_model.generate_content(prompt)
        refined = response.text.strip()
        # Try to pull out the refined dish name and procedure.
        if "Refined Dish Name:" in refined and "Refined Procedure:" in refined:
            refined_dish = refined.split("Refined Dish Name:")[-1].split("Refined Procedure:")[0].strip()
            refined_procedure = refined.split("Refined Procedure:")[-1].strip()
            return refined_dish, refined_procedure
        else:
            # If Gemini didn't give us what we expected, just use the original.
            return dish_name, procedure
    except Exception as e:
        print(f"Gemini API Error: {e}")
        return dish_name, procedure

# -------------------------------
# Function: Generate Recipe in Two Phases and Refine with Gemini
# -------------------------------
def generate_recipe(ingredients_input, temperature=1.0):
    """
    Generates a recipe in two steps: first the dish name, then the procedure.
    Then, it cleans everything up using Gemini.
    """
    # Get the ingredients ready.
    processed_ing_list = process_ingredients(ingredients_input)
    processed_ing = ", ".join(processed_ing_list)
    allowed_basics = ["salt", "sauce", "spices", "oil"]
    
    # First, let's generate the dish name.
    dish_seed = "<start> Dish:"
    dish_generated = generate_text(dish_seed, max_gen_words=6, stop_token="|", temperature=temperature)
    dish_part = dish_generated.replace("<start>", "").replace("Dish:", "").strip()
    dish_words = dish_part.split()
    dish_name = " ".join(dish_words[:4])
    
    # Now, let's get the procedure.
    seed_for_proc = (f"<start> Dish: {dish_name} | Ingredients: {processed_ing} | "
                     f"Note: Only use the specified ingredients and basic items ({', '.join(allowed_basics)}) for the recipe. | Procedure:")
    proc_generated = generate_text(seed_for_proc, max_gen_words=100, stop_token="<end>", temperature=temperature)
    if "| Procedure:" in proc_generated:
        procedure = proc_generated.split("| Procedure:")[-1].strip()
    else:
        procedure = proc_generated.strip()
    
    # Clean up the procedure text.
    procedure = re.sub(r'\bend\b', '', procedure, flags=re.IGNORECASE)
    procedure = re.sub(r'\s+', ' ', procedure).strip()
    
    # Clean up the dish name a bit too.
    dish_name = re.sub(r'\d+', '', dish_name)
    dish_name = re.sub(r'\bingredients?\b', '', dish_name, flags=re.IGNORECASE).strip()
    
    # Finally, let Gemini refine the whole thing.
    refined_dish, refined_procedure = refine_with_gemini(dish_name, procedure, processed_ing_list)
    
    return refined_dish, refined_procedure

# -------------------------------
# Testing: Generate Multiple Recipes per Input
# -------------------------------
test_inputs = [
    "capsicum, paneer , peas , chicken  "
]
temperature = 1.0
num_samples = 3

print("\n--- Generated Recipes ---")
for i, user_input in enumerate(test_inputs, start=1):
    processed_list = process_ingredients(user_input)
    print(f"\nFor Ingredients: {', '.join(processed_list)}")
    for j in range(num_samples):
        dish, procedure = generate_recipe(user_input, temperature=temperature)
        dish = " ".join(dish.split()[:4])
        print(f"\nRecipe {j+1} – {dish}")
        print("Procedure:", procedure)
    print("="*50)